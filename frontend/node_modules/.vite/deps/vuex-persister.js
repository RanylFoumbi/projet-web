import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next) {
        return deepmerge(prev, next, options);
      }, {});
    };
    var deepmerge_1 = deepmerge;
    module.exports = deepmerge_1;
  }
});

// node_modules/vuex-persister/src/index.ts
var import_deepmerge = __toESM(require_cjs());
var VuexPersister = class {
  constructor(options) {
    __publicField(this, "key");
    __publicField(this, "statesToPersist");
    __publicField(this, "persist");
    __publicField(this, "storage");
    __publicField(this, "overwrite");
    __publicField(this, "getState");
    __publicField(this, "saveState");
    __publicField(this, "reducer");
    /**
     * Rehydrates the state whenever there is a saved state
     * @param {boolean} overwrite - Whether to overwrite existing state or not
     * @param {Store} store - The store instance
     * @param {string} key - The storage key
     * @param {Storage} storage - The storage instance
     * @return {void}
     */
    __publicField(this, "rehydrateState", (overwrite, store, key, storage) => {
      const SAVED_STATE = this.getSavedState(key, storage);
      if (SAVED_STATE) {
        store.replaceState(
          this.overwrite ? SAVED_STATE : (0, import_deepmerge.default)(store.state, SAVED_STATE, {
            arrayMerge: (store2, saved) => saved
          })
        );
      }
    });
    /**
     * Saves the state on the storage
     * @param {string} key - The storage key
     * @param {State} state - The state to save
     * @param {Storage} storage - The storage to which to save the state
     * @returns {void}
     */
    __publicField(this, "saveCurrentState", (key, state, storage) => {
      storage.setItem(key, JSON.stringify(state));
    });
    /**
     * Gets the saved state
     * @param {string} key - The storage key
     * @param {Storage} storage - The storage to which to save the state
     * @returns {object|undefined} - The saved state
     */
    __publicField(this, "getSavedState", (key, storage) => {
      const STATE_VALUE = storage.getItem(key);
      try {
        let STATE;
        switch (typeof STATE_VALUE) {
          case "string":
            STATE = JSON.parse(STATE_VALUE);
            break;
          case "object":
            STATE = STATE_VALUE;
            break;
          default:
            STATE = null;
            break;
        }
        return STATE;
      } catch (err) {
        return null;
      }
    });
    /**
     * Returns the state to persist based on specified states to be persisted
     * @param statesToPersist - An array of states to be persisted
     * @param state - The existing state
     * @returns {State} - The state to be persisted
     */
    __publicField(this, "stateReducer", (statesToPersist, state) => statesToPersist.length > 0 ? statesToPersist.length === 1 ? this.reducedStatePair(statesToPersist[0], state) : statesToPersist.reduce((prev, curr) => (0, import_deepmerge.default)(
      this.reducedStatePair(prev, state),
      this.reducedStatePair(curr, state)
    )) : state);
    /**
     * Creates a key-value pair of state objects, based on the specified states to save
     * @param stateKey - The specified key in the state that needs to be persisted
     * @param state - The existing state
     * @return {object} - The state key-value pair that will be persisted
     */
    __publicField(this, "reducedStatePair", (stateKey, state) => {
      return { [this.reducedStateKey(stateKey)]: this.reducedStateValue(stateKey, state) };
    });
    /**
     * Returns the key for the state to be persisted
     * @param targetState - Target state to be persisted
     * @return {string} -The state key (to be persisted)
     */
    __publicField(this, "reducedStateKey", (targetState) => /\./.test(targetState) ? targetState.split(".")[0] : targetState);
    /**
     * Returns the value for the state key to be persisted
     * @param targetState - Target state to be persisted
     * @param state - Existing state
     * @return {any} - The state value to be persisted
     */
    __publicField(this, "reducedStateValue", (targetState, state) => {
      if (/\./.test(targetState)) {
        const splitPathModule = targetState.split(".");
        return { [splitPathModule[1]]: state[splitPathModule[0]][splitPathModule[1]] };
      } else {
        return state[targetState];
      }
    });
    /**
     * Exposes hooks for each mutation - called after every mutation
     * @param {object} store - The store instance
     * @returns {function} - The store.subscribe function that is called after every mutation
     */
    __publicField(this, "subscriber", (store) => (handler) => store.subscribe(handler));
    this.key = (options == null ? void 0 : options.key) ?? "vuex";
    this.statesToPersist = (options == null ? void 0 : options.statesToPersist) ?? [];
    this.overwrite = (options == null ? void 0 : options.overwrite) ?? false;
    this.storage = (options == null ? void 0 : options.storage) ?? ((window == null ? void 0 : window.localStorage) ?? localStorage);
    this.getState = (options == null ? void 0 : options.getState) ?? this.getSavedState;
    this.saveState = (options == null ? void 0 : options.saveState) ?? this.saveCurrentState;
    this.reducer = (options == null ? void 0 : options.reducer) ?? this.stateReducer;
    this.persist = (store) => {
      this.rehydrateState(this.overwrite, store, this.key, this.storage);
      this.subscriber(store)((mutation, state) => {
        this.saveState(this.key, this.reducer(this.statesToPersist, state), this.storage);
      });
    };
  }
};
export {
  VuexPersister as default
};
//# sourceMappingURL=vuex-persister.js.map
