import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';
import * as vue from 'vue';
import { Ref, App, MaybeRefOrGetter, InjectionKey } from 'vue';

interface DocumentDecoration<Result = {
    [key: string]: any;
}, Variables = {
    [key: string]: any;
}> {
    /** Type to support `@graphql-typed-document-node/core`
     * @internal
     */
    __apiType?: (variables: Variables) => Result;
    /** Type to support `TypedQueryDocumentNode` from `graphql`
     * @internal
     */
    __ensureTypesOfVariablesAndResultMatching?: (variables: Variables) => Result;
}
interface GraphQLResponse<TData> {
    data: TData;
    errors: any;
}
interface FetchOptions extends RequestInit {
    url?: string;
    headers: NonNullable<Record<string, string>>;
}
interface ParsedResponse<TData> {
    ok: boolean;
    status: number;
    statusText: string;
    headers: Headers;
    body: GraphQLResponse<TData> | null;
}
interface Operation<TData, TVars> {
    query: string | DocumentNode | DocumentDecoration<TData, TVars>;
    variables?: TVars;
}
type QueryVariables = Record<string, any>;

declare function parseResponse<TData>(response: Response): Promise<ParsedResponse<TData>>;
declare function mergeFetchOpts(lhs: FetchOptions, rhs: FetchOptions): {
    method: string;
    headers: {
        [x: string]: string;
    };
    url?: string;
    body?: BodyInit;
    cache?: RequestCache;
    credentials?: RequestCredentials;
    integrity?: string;
    keepalive?: boolean;
    mode?: RequestMode;
    priority?: RequestPriority;
    redirect?: RequestRedirect;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
    signal?: AbortSignal;
    window?: null;
};
declare function makeFetchOptions({ query, variables }: Operation<unknown, QueryVariables>, opts: FetchOptions): {
    method: string;
    headers: {
        [x: string]: string;
    };
    url?: string;
    body?: BodyInit;
    cache?: RequestCache;
    credentials?: RequestCredentials;
    integrity?: string;
    keepalive?: boolean;
    mode?: RequestMode;
    priority?: RequestPriority;
    redirect?: RequestRedirect;
    referrer?: string;
    referrerPolicy?: ReferrerPolicy;
    signal?: AbortSignal;
    window?: null;
};

/**
 * Normalizes a query string or object to a string.
 */
declare function normalizeQuery(query: string | DocumentNode | DocumentDecoration<any, any>): string | null;

declare class CombinedError extends Error {
    name: 'CombinedError';
    message: string;
    response: any;
    networkError?: Error;
    graphqlErrors?: GraphQLError[];
    constructor({ response, networkError, graphqlErrors, }: {
        response: any;
        networkError?: Error;
        graphqlErrors?: Array<string | GraphQLError | Error>;
    });
    get isGraphQLError(): boolean;
    toString(): string;
}

interface OperationResult<TData = any> {
    data: TData | null;
    error: CombinedError | null;
}
type CachePolicy = 'cache-and-network' | 'network-only' | 'cache-first' | 'cache-only';
type StandardOperationResult<TData = any> = ExecutionResult<TData>;
type MaybePromise<T> = T | Promise<T>;
interface ObserverLike<T> {
    next: (value: T) => void;
    error: (err: any) => void;
    complete: () => void;
}
interface Unsubscribable {
    unsubscribe: () => void;
}
/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */
interface ObservableLike<T> {
    subscribe(observer: ObserverLike<T>): Unsubscribable;
}
type OperationType = 'query' | 'mutation' | 'subscription';
type AfterQueryCallback = (result: OperationResult, ctx: {
    response?: ParsedResponse<unknown>;
}) => void | Promise<void>;
interface QueryOperation<TData, TVars> extends Operation<TData, TVars> {
    type: 'query';
    cachePolicy?: CachePolicy;
    tags?: string[];
}
interface MutationOperation<TData, TVars> extends Operation<TData, TVars> {
    type: 'mutation';
    clearCacheTags?: string[];
}
interface SubscriptionOperation<TData, TVars> extends Operation<TData, TVars> {
    type: 'subscription';
}
type OperationWithCachePolicy<TData, TVars> = QueryOperation<TData, TVars> | MutationOperation<TData, TVars> | SubscriptionOperation<TData, TVars>;
type ClientPluginOperation = OperationWithCachePolicy<unknown, QueryVariables> & {
    key: number;
};
interface QueryExecutionContext {
    headers: Record<string, string>;
}
interface ClientPluginContext {
    useResult: (result: OperationResult<unknown>, terminate?: boolean) => void;
    afterQuery: (cb: AfterQueryCallback) => void;
    operation: ClientPluginOperation;
    opContext: FetchOptions;
    response?: ParsedResponse<unknown>;
}
type ClientPlugin = ({ useResult, operation }: ClientPluginContext) => void | Promise<void>;
type QueryPredicateOrSignal<TVars = QueryVariables> = boolean | Ref<boolean> | ((variables: TVars) => boolean);

interface ClientOptions {
    url: string;
    cachePolicy?: CachePolicy;
    use?: ClientPlugin[];
}
/**
 * Sets or unsets the active client
 *
 * @param client - villus client instance
 */
declare const setActiveClient: (client: Client | undefined) => Client;
/**
 * Get the currently active client if there is any.
 */
declare const getActiveClient: () => any;
type OnResultChangedCallback<TData> = (result: OperationResult<TData>) => unknown;
declare const defaultPlugins: () => ClientPlugin[];
declare class Client {
    install: (app: App) => void;
    private url;
    private defaultCachePolicy;
    private plugins;
    private taggedQueries;
    constructor(opts: ClientOptions);
    /**
     * Executes an operation and returns a normalized response.
     */
    private execute;
    executeQuery<TData = any, TVars = QueryVariables>(operation: Omit<QueryOperation<TData, TVars>, 'type'>, queryContext?: QueryExecutionContext, onResultChanged?: OnResultChangedCallback<TData>): Promise<OperationResult<TData>>;
    executeMutation<TData = any, TVars = QueryVariables>(operation: Omit<MutationOperation<TData, TVars>, 'type'>, queryContext?: QueryExecutionContext): Promise<OperationResult<TData>>;
    executeSubscription<TData = any, TVars = QueryVariables>(operation: Omit<SubscriptionOperation<TData, TVars>, 'type'>): Promise<ObservableLike<StandardOperationResult<TData>>>;
    registerTaggedQuery(tags: string[], refetch: () => Promise<void>): symbol;
    unregisterTaggedQuery(id: symbol): void;
    refetchTaggedQueries(tags: string[]): Promise<any>;
}
declare function createClient(opts: ClientOptions): Client;

declare function useClient(opts: ClientOptions): Client;

declare function getQueryKey(operation: Operation<any, any>, ...components: string[]): number;

interface QueryCompositeOptions<TData, TVars> {
    query: MaybeRefOrGetter<Operation<TData, TVars>['query']>;
    variables?: MaybeRefOrGetter<TVars>;
    context?: MaybeRefOrGetter<QueryExecutionContext>;
    cachePolicy?: CachePolicy;
    fetchOnMount?: boolean;
    client?: Client;
    paused?: QueryPredicateOrSignal<TVars>;
    skip?: QueryPredicateOrSignal<TVars>;
    tags?: string[];
    onData?: (data: TData) => void;
    onError?: (err: CombinedError) => void;
}
interface QueryExecutionOpts<TVars> {
    cachePolicy: CachePolicy;
    variables: TVars;
}
type DataHookHandler<TData> = (data: TData) => unknown;
type ErrorHookHandler = (error: CombinedError) => unknown;
type UnregisterHookFn = () => void;
interface BaseQueryApi<TData = any, TVars = QueryVariables, TMappedData = TData | null> {
    data: Ref<TMappedData>;
    isFetching: Ref<boolean>;
    isDone: Ref<boolean>;
    error: Ref<CombinedError | null>;
    onData(handler: DataHookHandler<TData>): UnregisterHookFn;
    onError(handler: ErrorHookHandler): UnregisterHookFn;
    execute(overrideOpts?: Partial<QueryExecutionOpts<TVars>>): Promise<{
        data: TData | null;
        error: CombinedError | null;
    }>;
}
type DataMapper<TData = any, TResult = TData> = (value: OperationResult<TData>) => TResult;
interface QueryApi<TData, TVars, TMappedData = TData | null> extends BaseQueryApi<TData, TVars, TMappedData> {
    then(onFulfilled: (value: BaseQueryApi<TData, TVars, TMappedData>) => any): Promise<BaseQueryApi<TData, TVars, TMappedData>>;
}
declare function useQuery<TData = any, TVars = QueryVariables, TMappedData = TData | null>(opts: QueryCompositeOptions<TData, TVars>, mapData?: DataMapper<TData, TMappedData>): QueryApi<TData, TVars, TMappedData>;

interface MutationExecutionOptions<TData> {
    context: MaybeRefOrGetter<QueryExecutionContext>;
    client?: Client;
    clearCacheTags?: string[];
    refetchTags?: string[];
    onData?: (data: TData) => void;
    onError?: (err: CombinedError) => void;
}
interface MutationResult<TData> {
    data: TData | null;
    error: CombinedError | null;
}
interface MutationApi<TData, TVars> {
    data: Ref<TData | null>;
    isFetching: Ref<boolean>;
    isDone: Ref<boolean>;
    error: Ref<CombinedError | null>;
    execute(vars?: TVars): Promise<MutationResult<TData>>;
}
declare function useMutation<TData = any, TVars = QueryVariables>(query: Operation<TData, TVars>['query'], opts?: Partial<MutationExecutionOptions<TData>>): MutationApi<TData, TVars>;

interface SubscriptionCompositeOptions<TData, TVars, TResult = TData> {
    query: MaybeRefOrGetter<Operation<TData, TVars>['query']>;
    variables?: MaybeRefOrGetter<TVars>;
    skip?: QueryPredicateOrSignal<TVars>;
    paused?: QueryPredicateOrSignal<TVars>;
    client?: Client;
    initialData?: TResult;
    subscribeOnMount?: boolean;
}
type Reducer<TData = any, TResult = TData> = (value: OperationResult<TData>, prev: TResult | null) => TResult;
declare function useSubscription<TData = any, TResult = TData, TVars = QueryVariables>(opts: SubscriptionCompositeOptions<TData, TVars, TResult>, reduce?: Reducer<TData, TResult>): {
    data: Ref<vue.UnwrapRef<TResult>>;
    error: Ref<CombinedError>;
    paused: vue.ComputedRef<boolean>;
    isFetching: Ref<boolean>;
    subscribe: () => void;
    unsubscribe: () => void;
};

type SubscriptionForwarder<TData = any> = (operation: Omit<ClientPluginOperation, 'query'> & {
    query: string;
}) => MaybePromise<ObservableLike<StandardOperationResult<TData>>>;
declare function handleSubscriptions(forwarder: SubscriptionForwarder): ClientPlugin;

interface FetchPluginOpts {
    fetch?: (typeof window)['fetch'];
}
declare function fetch(opts?: FetchPluginOpts): ClientPlugin;

declare function cache(): ClientPlugin & {
    clearCache(tags?: string | string[]): void;
};

declare function dedup(): ClientPlugin;

declare function definePlugin(fn: ClientPlugin): ClientPlugin;

declare const VILLUS_CLIENT: InjectionKey<Client>;

export { type AfterQueryCallback, type BaseQueryApi, type CachePolicy, Client, type ClientOptions, type ClientPlugin, type ClientPluginContext, type ClientPluginOperation, CombinedError, type DataHookHandler, type DocumentDecoration, type ErrorHookHandler, type FetchOptions, type GraphQLResponse, type MaybePromise, type MutationApi, type MutationOperation, type MutationResult, type ObservableLike, type ObserverLike, type Operation, type OperationResult, type OperationType, type OperationWithCachePolicy, type ParsedResponse, type QueryApi, type QueryCompositeOptions, type QueryExecutionContext, type QueryExecutionOpts, type QueryOperation, type QueryPredicateOrSignal, type QueryVariables, type Reducer, type StandardOperationResult, type SubscriptionForwarder, type SubscriptionOperation, type Unsubscribable, VILLUS_CLIENT, cache, createClient, dedup, defaultPlugins, definePlugin, fetch, getActiveClient, getQueryKey, handleSubscriptions, makeFetchOptions, mergeFetchOpts, normalizeQuery, parseResponse, setActiveClient, useClient, useMutation, useQuery, useSubscription };
